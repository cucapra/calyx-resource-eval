extern "/scratch/anshuman/calyx/primitives/memories.sv" {
  primitive seq_mem_d1[WIDTH, SIZE, IDX_SIZE](@clk clk: 1, @reset reset: 1, @data addr0: IDX_SIZE, @write_together @static @go write_en: 1, @write_together @data write_data: WIDTH, @static @go(2) read_en: 1) -> (@stable read_data: WIDTH, @done write_done: 1, @done(2) read_done: 1);
  primitive seq_mem_d2[WIDTH, D0_SIZE, D1_SIZE, D0_IDX_SIZE, D1_IDX_SIZE](@clk clk: 1, @reset reset: 1, @data addr0: D0_IDX_SIZE, @data addr1: D1_IDX_SIZE, @write_together @static @go write_en: 1, @write_together @data write_data: WIDTH, @static @go(2) read_en: 1) -> (@stable read_data: WIDTH, @done write_done: 1, @done(2) read_done: 1);
  primitive seq_mem_d3[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE](@clk clk: 1, @reset reset: 1, @data addr0: D0_IDX_SIZE, @data addr1: D1_IDX_SIZE, @data addr2: D2_IDX_SIZE, @write_together @static @go write_en: 1, @write_together @data write_data: WIDTH, @static @go(2) read_en: 1) -> (@stable read_data: WIDTH, @done write_done: 1, @done(2) read_done: 1);
  primitive seq_mem_d4[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D3_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE, D3_IDX_SIZE](@clk clk: 1, @reset reset: 1, @data addr0: D0_IDX_SIZE, @data addr1: D1_IDX_SIZE, @data addr2: D2_IDX_SIZE, @data addr3: D3_IDX_SIZE, @write_together @static @go write_en: 1, @write_together @data write_data: WIDTH, @static @go(2) read_en: 1) -> (@stable read_data: WIDTH, @done write_done: 1, @done(2) read_done: 1);
}
extern "/scratch/anshuman/calyx/primitives/binary_operators.sv" {
  comb primitive std_fp_add<"share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_fp_sub<"share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  primitive std_fp_mult_pipe<"state_share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@clk clk: 1, @reset reset: 1, @write_together @static(3) @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (@stable out: WIDTH, @done done: 1);
  primitive std_fp_div_pipe<"state_share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@clk clk: 1, @reset reset: 1, @write_together @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (@stable out_remainder: WIDTH, @stable out_quotient: WIDTH, @done done: 1);
  comb primitive std_fp_gt<"share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_fp_sadd<"share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_fp_ssub<"share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  primitive std_fp_smult_pipe<"state_share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@clk clk: 1, @reset reset: 1, @write_together @static(3) @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (@stable out: WIDTH, @done done: 1);
  primitive std_fp_sdiv_pipe<"state_share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@clk clk: 1, @reset reset: 1, @write_together @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (@stable out_remainder: WIDTH, @stable out_quotient: WIDTH, @done done: 1);
  comb primitive std_fp_sgt<"share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_fp_slt<"share"=1>[WIDTH, INT_WIDTH, FRAC_WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  primitive std_mult_pipe<"state_share"=1>[WIDTH](@clk clk: 1, @reset reset: 1, @write_together @static(3) @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (@stable out: WIDTH, @done done: 1);
  primitive std_div_pipe<"state_share"=1>[WIDTH](@clk clk: 1, @reset reset: 1, @write_together @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (@stable out_quotient: WIDTH, @stable out_remainder: WIDTH, @done done: 1);
  comb primitive std_sadd<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_ssub<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  primitive std_smult_pipe<"state_share"=1>[WIDTH](@clk clk: 1, @reset reset: 1, @write_together @static(3) @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (@stable out: WIDTH, @done done: 1);
  primitive std_sdiv_pipe[WIDTH](@clk clk: 1, @reset reset: 1, @write_together @go go: 1, @write_together @data left: WIDTH, @write_together @data right: WIDTH) -> (out_quotient: WIDTH, out_remainder: WIDTH, @done done: 1);
  comb primitive std_sgt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_slt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_seq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_sneq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_sge<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_sle<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_slsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_srsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_signext<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
}
extern "/scratch/anshuman/calyx/primitives/core.sv" {
  comb primitive std_slice<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
  comb primitive std_pad<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH);
  comb primitive std_cat<"share"=1>[LEFT_WIDTH, RIGHT_WIDTH, OUT_WIDTH](@data left: LEFT_WIDTH, @data right: RIGHT_WIDTH) -> (out: OUT_WIDTH);
  comb primitive std_not<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH);
  comb primitive std_and<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_or<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_xor<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_sub<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_gt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_lt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_eq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_neq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_ge<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_le<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1);
  comb primitive std_lsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_rsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH);
  comb primitive std_mux<"share"=1>[WIDTH](@data cond: 1, @data tru: WIDTH, @data fal: WIDTH) -> (out: WIDTH);
  primitive std_mem_d1[WIDTH, SIZE, IDX_SIZE](@read_together addr0: IDX_SIZE, @write_together @data write_data: WIDTH, @write_together @static @go write_en: 1, @clk clk: 1, @reset reset: 1) -> (@read_together read_data: WIDTH, @done done: 1);
  primitive std_mem_d2[WIDTH, D0_SIZE, D1_SIZE, D0_IDX_SIZE, D1_IDX_SIZE](@read_together @write_together(2) addr0: D0_IDX_SIZE, @read_together @write_together(2) addr1: D1_IDX_SIZE, @write_together @data write_data: WIDTH, @write_together @static @go write_en: 1, @clk clk: 1, @reset reset: 1) -> (@read_together read_data: WIDTH, @done done: 1);
  primitive std_mem_d3[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE](@read_together @write_together(2) addr0: D0_IDX_SIZE, @read_together @write_together(2) addr1: D1_IDX_SIZE, @read_together @write_together(2) addr2: D2_IDX_SIZE, @write_together @data write_data: WIDTH, @write_together @static @go write_en: 1, @clk clk: 1, @reset reset: 1) -> (@read_together read_data: WIDTH, @done done: 1);
  primitive std_mem_d4[WIDTH, D0_SIZE, D1_SIZE, D2_SIZE, D3_SIZE, D0_IDX_SIZE, D1_IDX_SIZE, D2_IDX_SIZE, D3_IDX_SIZE](@read_together @write_together(2) addr0: D0_IDX_SIZE, @read_together @write_together(2) addr1: D1_IDX_SIZE, @read_together @write_together(2) addr2: D2_IDX_SIZE, @read_together @write_together(2) addr3: D3_IDX_SIZE, @write_together @data write_data: WIDTH, @write_together @static @go write_en: 1, @clk clk: 1) -> (@read_together read_data: WIDTH, @done done: 1);
}
primitive undef<"share"=1>[WIDTH]() -> (out: WIDTH) {
  assign out = 'x;
}
comb primitive std_const<"share"=1>[WIDTH, VALUE]() -> (out: WIDTH) {
  assign out = VALUE;
}
comb primitive std_wire<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH) {
  assign out = in;
}
comb primitive std_add<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH) {
  assign out = left + right;
}
primitive std_reg<"state_share"=1>[WIDTH](@write_together @data in: WIDTH, @write_together @static @go write_en: 1, @clk clk: 1, @reset reset: 1) -> (@stable out: WIDTH, @done done: 1) {
  always_ff @(posedge clk) begin
    if (reset) begin
       out <= 0;
       done <= 0;
    end else if (write_en) begin
      out <= in;
      done <= 1'd1;
    end else done <= 1'd0;
  end
}
static<1> component stats<"promoted"=1>(flow: 1, @go go: 1, @clk clk: 1, @reset reset: 1) -> (count_0: 32, count_1: 32, @done done: 1) {
  cells {
    count_0_sto = std_reg(32);
    count_1_sto = std_reg(32);
    count_0_sto_incr = std_add(32);
    count_1_sto_incr = std_add(32);
    eq_1 = std_eq(1);
  }
  wires {
    static<1> group count_0_sto_incr_group0 {
      count_0_sto_incr.left = count_0_sto.out;
      count_0_sto_incr.right = 32'd1;
      count_0_sto.write_en = 1'd1;
      count_0_sto.in = count_0_sto_incr.out;
    }
    static<1> group count_1_sto_incr_group0 {
      count_1_sto_incr.left = count_1_sto.out;
      count_1_sto_incr.right = 32'd1;
      count_1_sto.write_en = 1'd1;
      count_1_sto.in = count_1_sto_incr.out;
    }
    count_0 = count_0_sto.out;
    count_1 = count_1_sto.out;
  }
  control {
    static<1> if  eq_1.out {
      count_0_sto_incr_group0;
    } else {
      count_1_sto_incr_group0;
    }
  }
}
component fifo_purple(cmd: 2, value: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    mem = seq_mem_d1(32, 10, 32);
    next_write = std_reg(32);
    next_read = std_reg(32);
    ref ans = std_reg(32);
    ref err = std_reg(1);
    len = std_reg(32);
    eq_1 = std_eq(2);
    eq_2 = std_eq(2);
    eq_3 = std_eq(2);
    eq_4 = std_eq(32);
    eq_5 = std_eq(32);
    eq_6 = std_eq(32);
    eq_7 = std_eq(32);
    next_write_incr = std_add(32);
    next_read_incr = std_add(32);
    len_incr = std_add(32);
    len_decr = std_sub(32);
  }
  wires {
    group len_incr_group<"promote_static"=1> {
      len_incr.left = len.out;
      len_incr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_incr.out;
      len_incr_group[done] = len.done;
    }
    group len_decr_group<"promote_static"=1> {
      len_decr.left = len.out;
      len_decr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_decr.out;
      len_decr_group[done] = len.done;
    }
    group flash_write<"promote_static"=1> {
      next_write.in = 32'd0;
      next_write.write_en = 1'd1;
      flash_write[done] = next_write.done;
    }
    group flash_read<"promote_static"=1> {
      next_read.in = 32'd0;
      next_read.write_en = 1'd1;
      flash_read[done] = next_read.done;
    }
    static<1> group raise_err0 {
      err.in = 1'd1;
      err.write_en = 1'd1;
    }
    static<1> group flash_ans0 {
      ans.in = 32'd0;
      ans.write_en = 1'd1;
    }
    static<1> group read_payload_from_mem_phase10 {
      mem.addr0 = next_read.out;
      mem.read_en = 1'd1;
    }
    static<1> group read_payload_from_mem_phase20 {
      ans.write_en = 1'd1;
      ans.in = mem.read_data;
    }
    static<1> group next_read_incr_group0 {
      next_read_incr.left = next_read.out;
      next_read_incr.right = 32'd1;
      next_read.write_en = 1'd1;
      next_read.in = next_read_incr.out;
    }
    static<1> group write_payload_to_mem0 {
      mem.addr0 = next_write.out;
      mem.write_en = 1'd1;
      mem.write_data = value;
    }
    static<1> group next_write_incr_group0 {
      next_write_incr.left = next_write.out;
      next_write_incr.right = 32'd1;
      next_write.write_en = 1'd1;
      next_write.in = next_write_incr.out;
    }
    comb group eq_1_group {
      eq_1.left = cmd;
      eq_1.right = 2'd0;
    }
    comb group eq_2_group {
      eq_2.left = cmd;
      eq_2.right = 2'd1;
    }
    comb group eq_3_group {
      eq_3.left = cmd;
      eq_3.right = 2'd2;
    }
    comb group eq_4_group {
      eq_4.left = next_write.out;
      eq_4.right = 32'd10;
    }
    comb group eq_5_group {
      eq_5.left = next_read.out;
      eq_5.right = 32'd10;
    }
    comb group eq_6_group {
      eq_6.left = len.out;
      eq_6.right = 32'd0;
    }
    comb group eq_7_group {
      eq_7.left = len.out;
      eq_7.right = 32'd10;
    }
  }
  control {
    par {
      if eq_1.out with eq_1_group {
        if eq_6.out with eq_6_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<3> seq  {
              read_payload_from_mem_phase10;
              read_payload_from_mem_phase20;
              next_read_incr_group0;
            }
            if eq_5.out with eq_5_group {
              @promote_static flash_read;
            }
            @promote_static len_decr_group;
          }
        }
      }
      if eq_2.out with eq_2_group {
        static<2> if  eq_6.out {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          @compactable static<2> seq  {
            read_payload_from_mem_phase10;
            read_payload_from_mem_phase20;
          }
        }
      }
      if eq_3.out with eq_3_group {
        if eq_7.out with eq_7_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<2> seq  {
              write_payload_to_mem0;
              next_write_incr_group0;
            }
            if eq_4.out with eq_4_group {
              @promote_static flash_write;
            }
            @promote_static len_incr_group;
          }
        }
      }
    }
  }
}
component fifo_tangerine(cmd: 2, value: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    mem = seq_mem_d1(32, 10, 32);
    next_write = std_reg(32);
    next_read = std_reg(32);
    ref ans = std_reg(32);
    ref err = std_reg(1);
    len = std_reg(32);
    eq_1 = std_eq(2);
    eq_2 = std_eq(2);
    eq_3 = std_eq(2);
    eq_4 = std_eq(32);
    eq_5 = std_eq(32);
    eq_6 = std_eq(32);
    eq_7 = std_eq(32);
    next_write_incr = std_add(32);
    next_read_incr = std_add(32);
    len_incr = std_add(32);
    len_decr = std_sub(32);
  }
  wires {
    group len_incr_group<"promote_static"=1> {
      len_incr.left = len.out;
      len_incr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_incr.out;
      len_incr_group[done] = len.done;
    }
    group len_decr_group<"promote_static"=1> {
      len_decr.left = len.out;
      len_decr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_decr.out;
      len_decr_group[done] = len.done;
    }
    group flash_write<"promote_static"=1> {
      next_write.in = 32'd0;
      next_write.write_en = 1'd1;
      flash_write[done] = next_write.done;
    }
    group flash_read<"promote_static"=1> {
      next_read.in = 32'd0;
      next_read.write_en = 1'd1;
      flash_read[done] = next_read.done;
    }
    static<1> group raise_err0 {
      err.in = 1'd1;
      err.write_en = 1'd1;
    }
    static<1> group flash_ans0 {
      ans.in = 32'd0;
      ans.write_en = 1'd1;
    }
    static<1> group read_payload_from_mem_phase10 {
      mem.addr0 = next_read.out;
      mem.read_en = 1'd1;
    }
    static<1> group read_payload_from_mem_phase20 {
      ans.write_en = 1'd1;
      ans.in = mem.read_data;
    }
    static<1> group next_read_incr_group0 {
      next_read_incr.left = next_read.out;
      next_read_incr.right = 32'd1;
      next_read.write_en = 1'd1;
      next_read.in = next_read_incr.out;
    }
    static<1> group write_payload_to_mem0 {
      mem.addr0 = next_write.out;
      mem.write_en = 1'd1;
      mem.write_data = value;
    }
    static<1> group next_write_incr_group0 {
      next_write_incr.left = next_write.out;
      next_write_incr.right = 32'd1;
      next_write.write_en = 1'd1;
      next_write.in = next_write_incr.out;
    }
    comb group eq_1_group {
      eq_1.left = cmd;
      eq_1.right = 2'd0;
    }
    comb group eq_2_group {
      eq_2.left = cmd;
      eq_2.right = 2'd1;
    }
    comb group eq_3_group {
      eq_3.left = cmd;
      eq_3.right = 2'd2;
    }
    comb group eq_4_group {
      eq_4.left = next_write.out;
      eq_4.right = 32'd10;
    }
    comb group eq_5_group {
      eq_5.left = next_read.out;
      eq_5.right = 32'd10;
    }
    comb group eq_6_group {
      eq_6.left = len.out;
      eq_6.right = 32'd0;
    }
    comb group eq_7_group {
      eq_7.left = len.out;
      eq_7.right = 32'd10;
    }
  }
  control {
    par {
      if eq_1.out with eq_1_group {
        if eq_6.out with eq_6_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<3> seq  {
              read_payload_from_mem_phase10;
              read_payload_from_mem_phase20;
              next_read_incr_group0;
            }
            if eq_5.out with eq_5_group {
              @promote_static flash_read;
            }
            @promote_static len_decr_group;
          }
        }
      }
      if eq_2.out with eq_2_group {
        static<2> if  eq_6.out {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          @compactable static<2> seq  {
            read_payload_from_mem_phase10;
            read_payload_from_mem_phase20;
          }
        }
      }
      if eq_3.out with eq_3_group {
        if eq_7.out with eq_7_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<2> seq  {
              write_payload_to_mem0;
              next_write_incr_group0;
            }
            if eq_4.out with eq_4_group {
              @promote_static flash_write;
            }
            @promote_static len_incr_group;
          }
        }
      }
    }
  }
}
component pifo_red(cmd: 2, value: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    queue_l = fifo_purple();
    queue_r = fifo_tangerine();
    flow = std_reg(1);
    lt_1 = std_lt(32);
    ref ans = std_reg(32);
    ref err = std_reg(1);
    len = std_reg(32);
    hot = std_reg(1);
    eq_2 = std_eq(1);
    eq_3 = std_eq(32);
    eq_4 = std_eq(32);
    eq_5 = std_eq(2);
    eq_6 = std_eq(2);
    eq_7 = std_eq(2);
    eq_8 = std_eq(1);
    neq_9 = std_neq(1);
    hot_not = std_not(1);
    len_incr = std_add(32);
    len_decr = std_sub(32);
  }
  wires {
    group hot_not_group<"promote_static"=1> {
      hot_not.in = hot.out;
      hot.write_en = 1'd1;
      hot.in = hot_not.out;
      hot_not_group[done] = hot.done;
    }
    group lower_err<"promote_static"=1> {
      err.in = 1'd0;
      err.write_en = 1'd1;
      lower_err[done] = err.done;
    }
    group len_incr_group<"promote_static"=1> {
      len_incr.left = len.out;
      len_incr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_incr.out;
      len_incr_group[done] = len.done;
    }
    group len_decr_group<"promote_static"=1> {
      len_decr.left = len.out;
      len_decr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_decr.out;
      len_decr_group[done] = len.done;
    }
    static<1> group raise_err0 {
      err.in = 1'd1;
      err.write_en = 1'd1;
    }
    static<1> group flash_ans0 {
      ans.in = 32'd0;
      ans.write_en = 1'd1;
    }
    static<1> group lower_err0 {
      err.in = 1'd0;
      err.write_en = 1'd1;
    }
    static<1> group infer_flow0 {
      lt_1.left = 32'd100;
      lt_1.right = value;
      flow.write_en = 1'd1;
      flow.in = lt_1.out;
    }
    comb group eq_2_group {
      eq_2.left = hot.out;
      eq_2.right = 1'd0;
    }
    comb group eq_3_group {
      eq_3.left = len.out;
      eq_3.right = 32'd0;
    }
    comb group eq_4_group {
      eq_4.left = len.out;
      eq_4.right = 32'd10;
    }
    comb group eq_5_group {
      eq_5.left = cmd;
      eq_5.right = 2'd0;
    }
    comb group eq_6_group {
      eq_6.left = cmd;
      eq_6.right = 2'd1;
    }
    comb group eq_7_group {
      eq_7.left = cmd;
      eq_7.right = 2'd2;
    }
    comb group eq_8_group {
      eq_8.left = err.out;
      eq_8.right = 1'd0;
    }
    comb group neq_9_group {
      neq_9.left = err.out;
      neq_9.right = 1'd0;
    }
  }
  control {
    par {
      if eq_5.out with eq_5_group {
        if eq_3.out with eq_3_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @promote_static lower_err;
            if eq_2.out with eq_2_group {
              seq {
                invoke queue_l[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_r[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                } else {
                  @promote_static hot_not_group;
                }
              }
            } else {
              seq {
                invoke queue_r[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_l[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                } else {
                  @promote_static hot_not_group;
                }
              }
            }
            @promote_static len_decr_group;
          }
        }
      }
      if eq_6.out with eq_6_group {
        if eq_3.out with eq_3_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @promote_static lower_err;
            if eq_2.out with eq_2_group {
              seq {
                invoke queue_l[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_r[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                }
              }
            } else {
              seq {
                invoke queue_r[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_l[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                }
              }
            }
          }
        }
      }
      if eq_7.out with eq_7_group {
        if eq_4.out with eq_4_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<2> seq  {
              lower_err0;
              infer_flow0;
            }
            if flow.out {
              invoke queue_r[ans = ans,err = err](
                cmd = cmd,
                value = value
              )();
            } else {
              invoke queue_l[ans = ans,err = err](
                cmd = cmd,
                value = value
              )();
            }
            if eq_8.out with eq_8_group {
              @promote_static len_incr_group;
            }
          }
        }
      }
    }
  }
}
component fifo_blue(cmd: 2, value: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    mem = seq_mem_d1(32, 10, 32);
    next_write = std_reg(32);
    next_read = std_reg(32);
    ref ans = std_reg(32);
    ref err = std_reg(1);
    len = std_reg(32);
    eq_1 = std_eq(2);
    eq_2 = std_eq(2);
    eq_3 = std_eq(2);
    eq_4 = std_eq(32);
    eq_5 = std_eq(32);
    eq_6 = std_eq(32);
    eq_7 = std_eq(32);
    next_write_incr = std_add(32);
    next_read_incr = std_add(32);
    len_incr = std_add(32);
    len_decr = std_sub(32);
  }
  wires {
    group len_incr_group<"promote_static"=1> {
      len_incr.left = len.out;
      len_incr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_incr.out;
      len_incr_group[done] = len.done;
    }
    group len_decr_group<"promote_static"=1> {
      len_decr.left = len.out;
      len_decr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_decr.out;
      len_decr_group[done] = len.done;
    }
    group flash_write<"promote_static"=1> {
      next_write.in = 32'd0;
      next_write.write_en = 1'd1;
      flash_write[done] = next_write.done;
    }
    group flash_read<"promote_static"=1> {
      next_read.in = 32'd0;
      next_read.write_en = 1'd1;
      flash_read[done] = next_read.done;
    }
    static<1> group raise_err0 {
      err.in = 1'd1;
      err.write_en = 1'd1;
    }
    static<1> group flash_ans0 {
      ans.in = 32'd0;
      ans.write_en = 1'd1;
    }
    static<1> group read_payload_from_mem_phase10 {
      mem.addr0 = next_read.out;
      mem.read_en = 1'd1;
    }
    static<1> group read_payload_from_mem_phase20 {
      ans.write_en = 1'd1;
      ans.in = mem.read_data;
    }
    static<1> group next_read_incr_group0 {
      next_read_incr.left = next_read.out;
      next_read_incr.right = 32'd1;
      next_read.write_en = 1'd1;
      next_read.in = next_read_incr.out;
    }
    static<1> group write_payload_to_mem0 {
      mem.addr0 = next_write.out;
      mem.write_en = 1'd1;
      mem.write_data = value;
    }
    static<1> group next_write_incr_group0 {
      next_write_incr.left = next_write.out;
      next_write_incr.right = 32'd1;
      next_write.write_en = 1'd1;
      next_write.in = next_write_incr.out;
    }
    comb group eq_1_group {
      eq_1.left = cmd;
      eq_1.right = 2'd0;
    }
    comb group eq_2_group {
      eq_2.left = cmd;
      eq_2.right = 2'd1;
    }
    comb group eq_3_group {
      eq_3.left = cmd;
      eq_3.right = 2'd2;
    }
    comb group eq_4_group {
      eq_4.left = next_write.out;
      eq_4.right = 32'd10;
    }
    comb group eq_5_group {
      eq_5.left = next_read.out;
      eq_5.right = 32'd10;
    }
    comb group eq_6_group {
      eq_6.left = len.out;
      eq_6.right = 32'd0;
    }
    comb group eq_7_group {
      eq_7.left = len.out;
      eq_7.right = 32'd10;
    }
  }
  control {
    par {
      if eq_1.out with eq_1_group {
        if eq_6.out with eq_6_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<3> seq  {
              read_payload_from_mem_phase10;
              read_payload_from_mem_phase20;
              next_read_incr_group0;
            }
            if eq_5.out with eq_5_group {
              @promote_static flash_read;
            }
            @promote_static len_decr_group;
          }
        }
      }
      if eq_2.out with eq_2_group {
        static<2> if  eq_6.out {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          @compactable static<2> seq  {
            read_payload_from_mem_phase10;
            read_payload_from_mem_phase20;
          }
        }
      }
      if eq_3.out with eq_3_group {
        if eq_7.out with eq_7_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<2> seq  {
              write_payload_to_mem0;
              next_write_incr_group0;
            }
            if eq_4.out with eq_4_group {
              @promote_static flash_write;
            }
            @promote_static len_incr_group;
          }
        }
      }
    }
  }
}
component pifo_root(cmd: 2, value: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    queue_l = pifo_red();
    queue_r = fifo_blue();
    ref stats = stats();
    flow = std_reg(1);
    lt_1 = std_lt(32);
    ref ans = std_reg(32);
    ref err = std_reg(1);
    len = std_reg(32);
    hot = std_reg(1);
    eq_2 = std_eq(1);
    eq_3 = std_eq(32);
    eq_4 = std_eq(32);
    eq_5 = std_eq(2);
    eq_6 = std_eq(2);
    eq_7 = std_eq(2);
    eq_8 = std_eq(1);
    neq_9 = std_neq(1);
    hot_not = std_not(1);
    len_incr = std_add(32);
    len_decr = std_sub(32);
  }
  wires {
    group hot_not_group<"promote_static"=1> {
      hot_not.in = hot.out;
      hot.write_en = 1'd1;
      hot.in = hot_not.out;
      hot_not_group[done] = hot.done;
    }
    group lower_err<"promote_static"=1> {
      err.in = 1'd0;
      err.write_en = 1'd1;
      lower_err[done] = err.done;
    }
    group len_decr_group<"promote_static"=1> {
      len_decr.left = len.out;
      len_decr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_decr.out;
      len_decr_group[done] = len.done;
    }
    static<1> group raise_err0 {
      err.in = 1'd1;
      err.write_en = 1'd1;
    }
    static<1> group flash_ans0 {
      ans.in = 32'd0;
      ans.write_en = 1'd1;
    }
    static<1> group len_incr_group0 {
      len_incr.left = len.out;
      len_incr.right = 32'd1;
      len.write_en = 1'd1;
      len.in = len_incr.out;
    }
    static<1> group lower_err0 {
      err.in = 1'd0;
      err.write_en = 1'd1;
    }
    static<1> group infer_flow0 {
      lt_1.left = 32'd200;
      lt_1.right = value;
      flow.write_en = 1'd1;
      flow.in = lt_1.out;
    }
    comb group eq_2_group {
      eq_2.left = hot.out;
      eq_2.right = 1'd0;
    }
    comb group eq_3_group {
      eq_3.left = len.out;
      eq_3.right = 32'd0;
    }
    comb group eq_4_group {
      eq_4.left = len.out;
      eq_4.right = 32'd10;
    }
    comb group eq_5_group {
      eq_5.left = cmd;
      eq_5.right = 2'd0;
    }
    comb group eq_6_group {
      eq_6.left = cmd;
      eq_6.right = 2'd1;
    }
    comb group eq_7_group {
      eq_7.left = cmd;
      eq_7.right = 2'd2;
    }
    comb group eq_8_group {
      eq_8.left = err.out;
      eq_8.right = 1'd0;
    }
    comb group neq_9_group {
      neq_9.left = err.out;
      neq_9.right = 1'd0;
    }
  }
  control {
    par {
      if eq_5.out with eq_5_group {
        if eq_3.out with eq_3_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @promote_static lower_err;
            if eq_2.out with eq_2_group {
              seq {
                invoke queue_l[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_r[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                } else {
                  @promote_static hot_not_group;
                }
              }
            } else {
              seq {
                invoke queue_r[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_l[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                } else {
                  @promote_static hot_not_group;
                }
              }
            }
            @promote_static len_decr_group;
          }
        }
      }
      if eq_6.out with eq_6_group {
        if eq_3.out with eq_3_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @promote_static lower_err;
            if eq_2.out with eq_2_group {
              seq {
                invoke queue_l[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_r[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                }
              }
            } else {
              seq {
                invoke queue_r[ans = ans,err = err](
                  cmd = cmd,
                  value = value
                )();
                if neq_9.out with neq_9_group {
                  seq {
                    @promote_static lower_err;
                    invoke queue_l[ans = ans,err = err](
                      cmd = cmd,
                      value = value
                    )();
                  }
                }
              }
            }
          }
        }
      }
      if eq_7.out with eq_7_group {
        if eq_4.out with eq_4_group {
          static<1> par {
            raise_err0;
            flash_ans0;
          }
        } else {
          seq {
            @compactable static<2> seq  {
              lower_err0;
              infer_flow0;
            }
            if flow.out {
              invoke queue_r[ans = ans,err = err](
                cmd = cmd,
                value = value
              )();
            } else {
              invoke queue_l[ans = ans,err = err](
                cmd = cmd,
                value = value
              )();
            }
            if eq_8.out with eq_8_group {
              static<1> par {
                len_incr_group0;
                static<1> invoke stats(
                  flow = flow.out
                )();
              }
            }
          }
        }
      }
    }
  }
}
component dataplane(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    ref stats_runner = stats();
    myqueue = pifo_root();
    ref commands = seq_mem_d1(2, 20000, 32);
    ref values = seq_mem_d1(32, 20000, 32);
    ref has_ans = std_reg(1);
    ref component_ans = std_reg(32);
    ref component_err = std_reg(1);
    i = std_reg(32);
    command = std_reg(2);
    value = std_reg(32);
    i_incr = std_add(32);
    le_1 = std_le(2);
    not_2 = std_not(1);
    i_eq_MAX_CMDS = std_eq(32);
  }
  wires {
    static<1> group raise_has_ans0 {
      has_ans.in = 1'd1;
      has_ans.write_en = 1'd1;
    }
    static<1> group lower_has_ans0 {
      has_ans.in = 1'd0;
      has_ans.write_en = 1'd1;
    }
    static<1> group read_cmd_phase10 {
      commands.addr0 = i.out;
      commands.read_en = 1'd1;
    }
    static<1> group write_cmd_phase20 {
      command.write_en = 1'd1;
      command.in = commands.read_data;
    }
    static<1> group read_value0 {
      values.addr0 = i.out;
      values.read_en = 1'd1;
    }
    static<1> group write_value_to_reg0 {
      value.write_en = 1'd1;
      value.in = values.read_data;
    }
    static<1> group i_incr_group0 {
      i_incr.left = i.out;
      i_incr.right = 32'd1;
      i.write_en = 1'd1;
      i.in = i_incr.out;
    }
    static<1> group i_eq_MAX_CMDS_group0 {
      i_eq_MAX_CMDS.left = i.out;
      i_eq_MAX_CMDS.right = 32'd20000;
      component_err.write_en = 1'd1;
      component_err.in = i_eq_MAX_CMDS.out;
    }
    comb group not_2_group {
      not_2.in = component_err.out;
    }
  }
  control {
    seq {
      @compactable static<4> seq  {
        read_cmd_phase10;
        write_cmd_phase20;
        read_value0;
        write_value_to_reg0;
      }
      invoke myqueue[ans = component_ans,err = component_err,stats = stats_runner](
        cmd = command.out,
        value = value.out
      )();
      if not_2.out with not_2_group {
        @promote_static seq {
          static<1> if  le_1.out {
            raise_has_ans0;
          } else {
            lower_has_ans0;
          }
        }
      }
      @compactable static<2> seq  {
        i_incr_group0;
        i_eq_MAX_CMDS_group0;
      }
    }
  }
}
component controller(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    ref stats_controller = stats();
    count_0 = std_reg(32);
    count_1 = std_reg(32);
  }
  wires {
    group get_data_locally {
      count_0.in = stats_controller.count_0;
      count_0.write_en = 1'd1;
      count_1.in = stats_controller.count_1;
      count_1.write_en = 1'd1;
      get_data_locally[done] = count_0.done & count_1.done ? 1'd1;
    }
  }
  control {
    get_data_locally;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    stats_main = stats();
    dataplane = dataplane();
    controller = controller();
    has_ans = std_reg(1);
    dataplane_ans = std_reg(32);
    dataplane_err = std_reg(1);
    @external commands = seq_mem_d1(2, 20000, 32);
    @external values = seq_mem_d1(32, 20000, 32);
    @external ans_mem = seq_mem_d1(32, 20000, 32);
    neq_1 = std_neq(32);
    j = std_reg(32);
    j_incr = std_add(32);
    not_2 = std_not(1);
  }
  wires {
    group lower_has_ans<"promote_static"=1> {
      has_ans.in = 1'd0;
      has_ans.write_en = 1'd1;
      lower_has_ans[done] = has_ans.done;
    }
    static<1> group write_ans0 {
      ans_mem.addr0 = j.out;
      ans_mem.write_en = 1'd1;
      ans_mem.write_data = dataplane_ans.out;
    }
    static<1> group j_incr_group0 {
      j_incr.left = j.out;
      j_incr.right = 32'd1;
      j.write_en = 1'd1;
      j.in = j_incr.out;
    }
    comb group neq_1_group {
      neq_1.left = dataplane_ans.out;
      neq_1.right = 32'd0;
    }
    comb group not_2_group {
      not_2.in = dataplane_err.out;
    }
  }
  control {
    while not_2.out with not_2_group {
      seq {
        @promote_static lower_has_ans;
        invoke dataplane[commands = commands,values = values,has_ans = has_ans,component_ans = dataplane_ans,component_err = dataplane_err,stats_runner = stats_main]()();
        if has_ans.out {
          if neq_1.out with neq_1_group {
            @compactable static<2> seq  {
              write_ans0;
              j_incr_group0;
            }
          }
        }
        invoke controller[stats_controller = stats_main]()();
      }
    }
  }
}
